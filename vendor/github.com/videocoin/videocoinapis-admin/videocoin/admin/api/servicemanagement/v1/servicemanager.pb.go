// Code generated by protoc-gen-go. DO NOT EDIT.
// source: videocoin/admin/api/servicemanagement/v1/servicemanager.proto

package v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Request message for `ListServices` method.
type ListServicesRequest struct {
	// The max number of items to include in the response list. Page size is 50
	// if not specified. Maximum value is 100.
	PageSize int32 `protobuf:"varint,1,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Token identifying which result to start with; returned by a previous list
	// call.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// Include services consumed by the specified consumer.
	//
	// The implementation accepts the following forms:
	// - project:<project_id>
	ConsumerId string `protobuf:"bytes,3,opt,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
}

func (m *ListServicesRequest) Reset()                    { *m = ListServicesRequest{} }
func (m *ListServicesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListServicesRequest) ProtoMessage()               {}
func (*ListServicesRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *ListServicesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListServicesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListServicesRequest) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

// Response message for `ListServices` method.
type ListServicesResponse struct {
	// The returned services will only have the name field set.
	Services []*ManagedService `protobuf:"bytes,1,rep,name=services" json:"services,omitempty"`
	// Token that can be passed to `ListServices` to resume a paginated query.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListServicesResponse) Reset()                    { *m = ListServicesResponse{} }
func (m *ListServicesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListServicesResponse) ProtoMessage()               {}
func (*ListServicesResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ListServicesResponse) GetServices() []*ManagedService {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *ListServicesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Request message for `GetService` method.
type GetServiceRequest struct {
	// Required. The name of the service. For example:
	// `symphony.videocoin.network`.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
}

func (m *GetServiceRequest) Reset()                    { *m = GetServiceRequest{} }
func (m *GetServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*GetServiceRequest) ProtoMessage()               {}
func (*GetServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *GetServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// Request message for CreateService method.
type CreateServiceRequest struct {
	// Required. Initial values for the service resource.
	Service *ManagedService `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
}

func (m *CreateServiceRequest) Reset()                    { *m = CreateServiceRequest{} }
func (m *CreateServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateServiceRequest) ProtoMessage()               {}
func (*CreateServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *CreateServiceRequest) GetService() *ManagedService {
	if m != nil {
		return m.Service
	}
	return nil
}

// Request message for DeleteService method.
type DeleteServiceRequest struct {
	// Required. The name of the service. For example:
	// `symphony.videocoin.network`.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
}

func (m *DeleteServiceRequest) Reset()                    { *m = DeleteServiceRequest{} }
func (m *DeleteServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteServiceRequest) ProtoMessage()               {}
func (*DeleteServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *DeleteServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// Request message for EnableService method.
type EnableServiceRequest struct {
	// Required. Name of the service to enable. Specifying an unknown service name
	// will cause the request to fail.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
	// Required. The identity of consumer resource which service enablement will
	// be applied to.
	//
	// The implementation accepts the following
	// forms:
	// - "project:<project_id>"
	ConsumerId string `protobuf:"bytes,2,opt,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
}

func (m *EnableServiceRequest) Reset()                    { *m = EnableServiceRequest{} }
func (m *EnableServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableServiceRequest) ProtoMessage()               {}
func (*EnableServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *EnableServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *EnableServiceRequest) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

// Request message for DisableService method.
type DisableServiceRequest struct {
	// Required. Name of the service to disable. Specifying an unknown service
	// name will cause the request to fail.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
	// Required. The identity of consumer resource which service disablement will
	// be applied to.
	//
	// The implementation accepts the following
	// forms:
	// - "project:<project_id>"
	//
	ConsumerId string `protobuf:"bytes,2,opt,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
}

func (m *DisableServiceRequest) Reset()                    { *m = DisableServiceRequest{} }
func (m *DisableServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*DisableServiceRequest) ProtoMessage()               {}
func (*DisableServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *DisableServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *DisableServiceRequest) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

func init() {
	proto.RegisterType((*ListServicesRequest)(nil), "videocoin.admin.api.servicemanagement.v1.ListServicesRequest")
	proto.RegisterType((*ListServicesResponse)(nil), "videocoin.admin.api.servicemanagement.v1.ListServicesResponse")
	proto.RegisterType((*GetServiceRequest)(nil), "videocoin.admin.api.servicemanagement.v1.GetServiceRequest")
	proto.RegisterType((*CreateServiceRequest)(nil), "videocoin.admin.api.servicemanagement.v1.CreateServiceRequest")
	proto.RegisterType((*DeleteServiceRequest)(nil), "videocoin.admin.api.servicemanagement.v1.DeleteServiceRequest")
	proto.RegisterType((*EnableServiceRequest)(nil), "videocoin.admin.api.servicemanagement.v1.EnableServiceRequest")
	proto.RegisterType((*DisableServiceRequest)(nil), "videocoin.admin.api.servicemanagement.v1.DisableServiceRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ServiceManager service

type ServiceManagerClient interface {
	// Lists managed services.
	//
	// Returns all public services.
	ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error)
	// Gets a managed service.
	GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*ManagedService, error)
	// Creates a new managed service.
	CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*ManagedService, error)
	// Deletes a managed service.
	DeleteService(ctx context.Context, in *DeleteServiceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Enables a
	// [service][videocoin.admin.api.servicemanagement.v1.ManagedService] for a
	// project, so it can be used for the project.
	EnableService(ctx context.Context, in *EnableServiceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Disables a
	// [service][videocoin.admin.api.servicemanagement.v1.ManagedService] for a
	// project, so it can no longer be be used for the project. It prevents
	// security leaks.
	DisableService(ctx context.Context, in *DisableServiceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type serviceManagerClient struct {
	cc *grpc.ClientConn
}

func NewServiceManagerClient(cc *grpc.ClientConn) ServiceManagerClient {
	return &serviceManagerClient{cc}
}

func (c *serviceManagerClient) ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error) {
	out := new(ListServicesResponse)
	err := grpc.Invoke(ctx, "/videocoin.admin.api.servicemanagement.v1.ServiceManager/ListServices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagerClient) GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*ManagedService, error) {
	out := new(ManagedService)
	err := grpc.Invoke(ctx, "/videocoin.admin.api.servicemanagement.v1.ServiceManager/GetService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagerClient) CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*ManagedService, error) {
	out := new(ManagedService)
	err := grpc.Invoke(ctx, "/videocoin.admin.api.servicemanagement.v1.ServiceManager/CreateService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagerClient) DeleteService(ctx context.Context, in *DeleteServiceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/videocoin.admin.api.servicemanagement.v1.ServiceManager/DeleteService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagerClient) EnableService(ctx context.Context, in *EnableServiceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/videocoin.admin.api.servicemanagement.v1.ServiceManager/EnableService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceManagerClient) DisableService(ctx context.Context, in *DisableServiceRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/videocoin.admin.api.servicemanagement.v1.ServiceManager/DisableService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServiceManager service

type ServiceManagerServer interface {
	// Lists managed services.
	//
	// Returns all public services.
	ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
	// Gets a managed service.
	GetService(context.Context, *GetServiceRequest) (*ManagedService, error)
	// Creates a new managed service.
	CreateService(context.Context, *CreateServiceRequest) (*ManagedService, error)
	// Deletes a managed service.
	DeleteService(context.Context, *DeleteServiceRequest) (*google_protobuf.Empty, error)
	// Enables a
	// [service][videocoin.admin.api.servicemanagement.v1.ManagedService] for a
	// project, so it can be used for the project.
	EnableService(context.Context, *EnableServiceRequest) (*google_protobuf.Empty, error)
	// Disables a
	// [service][videocoin.admin.api.servicemanagement.v1.ManagedService] for a
	// project, so it can no longer be be used for the project. It prevents
	// security leaks.
	DisableService(context.Context, *DisableServiceRequest) (*google_protobuf.Empty, error)
}

func RegisterServiceManagerServer(s *grpc.Server, srv ServiceManagerServer) {
	s.RegisterService(&_ServiceManager_serviceDesc, srv)
}

func _ServiceManager_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagerServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/videocoin.admin.api.servicemanagement.v1.ServiceManager/ListServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagerServer).ListServices(ctx, req.(*ListServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManager_GetService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagerServer).GetService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/videocoin.admin.api.servicemanagement.v1.ServiceManager/GetService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagerServer).GetService(ctx, req.(*GetServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManager_CreateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagerServer).CreateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/videocoin.admin.api.servicemanagement.v1.ServiceManager/CreateService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagerServer).CreateService(ctx, req.(*CreateServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManager_DeleteService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagerServer).DeleteService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/videocoin.admin.api.servicemanagement.v1.ServiceManager/DeleteService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagerServer).DeleteService(ctx, req.(*DeleteServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManager_EnableService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagerServer).EnableService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/videocoin.admin.api.servicemanagement.v1.ServiceManager/EnableService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagerServer).EnableService(ctx, req.(*EnableServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceManager_DisableService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceManagerServer).DisableService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/videocoin.admin.api.servicemanagement.v1.ServiceManager/DisableService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceManagerServer).DisableService(ctx, req.(*DisableServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "videocoin.admin.api.servicemanagement.v1.ServiceManager",
	HandlerType: (*ServiceManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListServices",
			Handler:    _ServiceManager_ListServices_Handler,
		},
		{
			MethodName: "GetService",
			Handler:    _ServiceManager_GetService_Handler,
		},
		{
			MethodName: "CreateService",
			Handler:    _ServiceManager_CreateService_Handler,
		},
		{
			MethodName: "DeleteService",
			Handler:    _ServiceManager_DeleteService_Handler,
		},
		{
			MethodName: "EnableService",
			Handler:    _ServiceManager_EnableService_Handler,
		},
		{
			MethodName: "DisableService",
			Handler:    _ServiceManager_DisableService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "videocoin/admin/api/servicemanagement/v1/servicemanager.proto",
}

func init() {
	proto.RegisterFile("videocoin/admin/api/servicemanagement/v1/servicemanager.proto", fileDescriptor1)
}

var fileDescriptor1 = []byte{
	// 489 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcf, 0x6b, 0xd4, 0x40,
	0x14, 0x6e, 0x5a, 0xaa, 0xdd, 0xb7, 0xdd, 0x8a, 0xe3, 0x2a, 0x4b, 0x8a, 0xb8, 0xe6, 0x20, 0xc1,
	0xc3, 0x84, 0x56, 0x90, 0x8a, 0x54, 0x41, 0x5b, 0x44, 0x50, 0x91, 0xb4, 0xa7, 0x7a, 0x58, 0x66,
	0x37, 0xcf, 0x65, 0xec, 0x66, 0x26, 0xce, 0x64, 0x17, 0xed, 0xdd, 0x93, 0x07, 0x2f, 0xfe, 0xb7,
	0x5e, 0x24, 0x33, 0x49, 0x35, 0x4d, 0x94, 0xa4, 0x4b, 0x2f, 0x81, 0xbc, 0x99, 0xef, 0xc7, 0xbc,
	0xf9, 0xe6, 0xc1, 0xfe, 0x82, 0x47, 0x28, 0x27, 0x92, 0x8b, 0x80, 0x45, 0x71, 0xf6, 0x4d, 0x78,
	0xa0, 0x51, 0x2d, 0xf8, 0x04, 0x63, 0x26, 0xd8, 0x14, 0x63, 0x14, 0x69, 0xb0, 0xd8, 0x29, 0x17,
	0x15, 0x4d, 0x94, 0x4c, 0x25, 0xf1, 0xcf, 0xe1, 0xd4, 0xc0, 0x29, 0x4b, 0x38, 0xad, 0xc0, 0xe9,
	0x62, 0xc7, 0xdd, 0x9e, 0x4a, 0x39, 0x9d, 0x61, 0x60, 0x70, 0xe3, 0xf9, 0xc7, 0x00, 0xe3, 0x24,
	0xfd, 0x6a, 0x69, 0xdc, 0xbd, 0xc6, 0x2e, 0x14, 0x6a, 0x39, 0x57, 0x13, 0xd4, 0x16, 0xe9, 0x29,
	0xb8, 0xf5, 0x86, 0xeb, 0xf4, 0xc8, 0xee, 0xd5, 0x21, 0x7e, 0x9e, 0xa3, 0x4e, 0xc9, 0x36, 0x74,
	0x12, 0x36, 0xc5, 0x91, 0xe6, 0x67, 0x38, 0x70, 0x86, 0x8e, 0xbf, 0x1e, 0x6e, 0x64, 0x85, 0x23,
	0x7e, 0x86, 0xe4, 0x2e, 0x80, 0x59, 0x4c, 0xe5, 0x29, 0x8a, 0xc1, 0xea, 0xd0, 0xf1, 0x3b, 0xa1,
	0xd9, 0x7e, 0x9c, 0x15, 0xc8, 0x3d, 0xe8, 0x4e, 0xa4, 0xd0, 0xf3, 0x18, 0xd5, 0x88, 0x47, 0x83,
	0x35, 0xb3, 0x0e, 0x45, 0xe9, 0x75, 0xe4, 0xfd, 0x74, 0xa0, 0x5f, 0x16, 0xd5, 0x89, 0x14, 0x1a,
	0xc9, 0x31, 0x6c, 0xe4, 0xa6, 0xf5, 0xc0, 0x19, 0xae, 0xf9, 0xdd, 0xdd, 0x3d, 0xda, 0xb4, 0x41,
	0xf4, 0xad, 0xf9, 0x8b, 0x72, 0xd2, 0xf0, 0x9c, 0x89, 0x3c, 0x80, 0x1b, 0x02, 0xbf, 0xa4, 0xa3,
	0x8a, 0xe7, 0x5e, 0x56, 0x7e, 0x5f, 0xf8, 0xf6, 0x1e, 0xc3, 0xcd, 0x57, 0x58, 0x98, 0x2a, 0x1a,
	0x71, 0x1f, 0x36, 0x73, 0xa2, 0x91, 0x60, 0xb1, 0xed, 0x45, 0x27, 0xec, 0xe6, 0xb5, 0x77, 0x2c,
	0x46, 0xef, 0x13, 0xf4, 0x5f, 0x2a, 0x64, 0x29, 0x5e, 0x80, 0x86, 0x70, 0x3d, 0xdf, 0x66, 0x50,
	0xcb, 0x1c, 0xa6, 0x20, 0xf2, 0x9e, 0x40, 0xff, 0x00, 0x67, 0x58, 0xd1, 0x6a, 0x60, 0xf3, 0x04,
	0xfa, 0x87, 0x82, 0x8d, 0x67, 0xed, 0xa1, 0x17, 0x6f, 0x74, 0xb5, 0x72, 0xa3, 0x1f, 0xe0, 0xf6,
	0x01, 0xd7, 0x57, 0x43, 0xbe, 0xfb, 0x6b, 0x1d, 0xb6, 0x72, 0x5a, 0xdb, 0x16, 0x45, 0x7e, 0x38,
	0xb0, 0xf9, 0x77, 0x82, 0xc8, 0x7e, 0xf3, 0xd6, 0xd6, 0xc4, 0xdd, 0x7d, 0x76, 0x59, 0xb8, 0x0d,
	0xae, 0xb7, 0x42, 0xbe, 0x39, 0x00, 0x7f, 0xd2, 0x43, 0x9e, 0x36, 0x27, 0xac, 0x64, 0xce, 0xbd,
	0x74, 0x4e, 0xbc, 0x15, 0xf2, 0xdd, 0x81, 0x5e, 0x29, 0x8d, 0xa4, 0xc5, 0xd9, 0xea, 0x62, 0xbc,
	0x94, 0x1b, 0x0e, 0xbd, 0x52, 0x5c, 0xdb, 0x98, 0xa9, 0xcb, 0xb9, 0x7b, 0x87, 0xda, 0x31, 0x48,
	0x8b, 0x31, 0x48, 0x0f, 0xb3, 0x31, 0x68, 0xa5, 0x4a, 0xf1, 0x6e, 0x23, 0x55, 0xf7, 0x2e, 0xfe,
	0x23, 0x75, 0x0a, 0x5b, 0xe5, 0xb4, 0x93, 0xe7, 0x2d, 0x8e, 0x55, 0xf7, 0x4e, 0xfe, 0x2d, 0xf6,
	0xe2, 0xe1, 0x89, 0xdf, 0x74, 0xb8, 0x8f, 0xaf, 0x19, 0xf4, 0xa3, 0xdf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0xab, 0xbb, 0x97, 0x14, 0x95, 0x06, 0x00, 0x00,
}
